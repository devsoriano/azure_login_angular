(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@azure/msal-browser'), require('rxjs'), require('@angular/router'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@azure/msal-angular', ['exports', '@angular/core', '@angular/common', '@azure/msal-browser', 'rxjs', '@angular/router', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.azure = global.azure || {}, global.azure['msal-angular'] = {}), global.ng.core, global.ng.common, global['@azure/msal-browser'], global.rxjs, global.ng.router, global.rxjs.operators));
}(this, (function (exports, core, common, msalBrowser, rxjs, router, operators) { 'use strict';

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MSAL_INSTANCE = new core.InjectionToken("MSAL_INSTANCE");
    var MSAL_GUARD_CONFIG = new core.InjectionToken("MSAL_GUARD_CONFIG");
    var MSAL_INTERCEPTOR_CONFIG = new core.InjectionToken("MSAL_INTERCEPTOR_CONFIG");

    /* eslint-disable header/header */
    var name = "@azure/msal-angular";
    var version = "2.0.0-alpha.6";

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalService = /** @class */ (function () {
        function MsalService(instance, location) {
            this.instance = instance;
            this.location = location;
            var hash = this.location.path(true).split("#").pop();
            if (hash) {
                this.redirectHash = "#" + hash;
            }
            this.instance.initializeWrapperLibrary(msalBrowser.WrapperSKU.Angular, version);
        }
        MsalService.prototype.acquireTokenPopup = function (request) {
            return rxjs.from(this.instance.acquireTokenPopup(request));
        };
        MsalService.prototype.acquireTokenRedirect = function (request) {
            return rxjs.from(this.instance.acquireTokenRedirect(request));
        };
        MsalService.prototype.acquireTokenSilent = function (silentRequest) {
            return rxjs.from(this.instance.acquireTokenSilent(silentRequest));
        };
        MsalService.prototype.handleRedirectObservable = function () {
            var handleRedirect = rxjs.from(this.instance.handleRedirectPromise(this.redirectHash));
            this.redirectHash = "";
            return handleRedirect;
        };
        MsalService.prototype.loginPopup = function (request) {
            return rxjs.from(this.instance.loginPopup(request));
        };
        MsalService.prototype.loginRedirect = function (request) {
            return rxjs.from(this.instance.loginRedirect(request));
        };
        MsalService.prototype.logout = function (logoutRequest) {
            return rxjs.from(this.instance.logout(logoutRequest));
        };
        MsalService.prototype.ssoSilent = function (request) {
            return rxjs.from(this.instance.ssoSilent(request));
        };
        /**
         * Gets logger for msal-angular.
         * If no logger set, returns logger instance created with same options as msal-browser
         */
        MsalService.prototype.getLogger = function () {
            if (!this.logger) {
                this.logger = this.instance.getLogger().clone(name, version);
            }
            return this.logger;
        };
        // Create a logger instance for msal-angular with the same options as msal-browser
        MsalService.prototype.setLogger = function (logger) {
            this.logger = logger.clone(name, version);
            this.instance.setLogger(logger);
        };
        return MsalService;
    }());
    MsalService.decorators = [
        { type: core.Injectable }
    ];
    MsalService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] },
        { type: common.Location }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalGuard = /** @class */ (function () {
        function MsalGuard(msalGuardConfig, authService, location, router) {
            this.msalGuardConfig = msalGuardConfig;
            this.authService = authService;
            this.location = location;
            this.router = router;
        }
        /**
         * Parses url string to UrlTree
         * @param url
         */
        MsalGuard.prototype.parseUrl = function (url) {
            return this.router.parseUrl(url);
        };
        /**
         * Builds the absolute url for the destination page
         * @param path Relative path of requested page
         * @returns Full destination url
         */
        MsalGuard.prototype.getDestinationUrl = function (path) {
            this.authService.getLogger().verbose("Guard - getting destination url");
            // Absolute base url for the application (default to origin if base element not present)
            var baseElements = document.getElementsByTagName("base");
            var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
            // Path of page (including hash, if using hash routing)
            var pathUrl = this.location.prepareExternalUrl(path);
            // Hash location strategy
            if (pathUrl.startsWith("#")) {
                this.authService.getLogger().verbose("Guard - destination by hash routing");
                return baseUrl + "/" + pathUrl;
            }
            /*
             * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
             * Since baseUrl also includes /base, can just concatentate baseUrl + path
             */
            return "" + baseUrl + path;
        };
        /**
         * Interactively prompt the user to login
         * @param url Path of the requested page
         */
        MsalGuard.prototype.loginInteractively = function (url) {
            var _this = this;
            if (this.msalGuardConfig.interactionType === msalBrowser.InteractionType.Popup) {
                this.authService.getLogger().verbose("Guard - logging in by popup");
                return this.authService.loginPopup(Object.assign({}, this.msalGuardConfig.authRequest))
                    .pipe(operators.map(function (response) {
                    _this.authService.getLogger().verbose("Guard - login by popup successful, can activate, setting active account");
                    _this.authService.instance.setActiveAccount(response.account);
                    return true;
                }));
            }
            this.authService.getLogger().verbose("Guard - logging in by redirect");
            var redirectStartPage = this.getDestinationUrl(url);
            return this.authService.loginRedirect(Object.assign({ redirectStartPage: redirectStartPage }, this.msalGuardConfig.authRequest))
                .pipe(operators.map(function () { return false; }));
        };
        /**
         * Helper which checks for the correct interaction type, prevents page with Guard to be set as reidrect, and calls handleRedirectObservable
         * @param state
         */
        MsalGuard.prototype.activateHelper = function (state) {
            var _this = this;
            if (this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Guard activated");
            /*
             * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
             * short-circuit to prevent redirecting or popups.
             * TODO: Update to allow running in iframe once allowRedirectInIframe is implemented
             */
            if (msalBrowser.UrlString.hashContainsKnownProperties(window.location.hash) && msalBrowser.BrowserUtils.isInIframe()) {
                this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
                return rxjs.of(false);
            }
            /**
             * If a loginFailedRoute is set in the config, set this as the loginFailedRoute
             */
            if (this.msalGuardConfig.loginFailedRoute) {
                this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute);
            }
            return this.authService.handleRedirectObservable()
                .pipe(operators.concatMap(function () {
                if (!_this.authService.instance.getAllAccounts().length) {
                    if (state) {
                        _this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate");
                        return _this.loginInteractively(state.url);
                    }
                    _this.authService.getLogger().verbose("Guard - no accounts retrieved, no state, cannot load");
                    return rxjs.of(false);
                }
                _this.authService.getLogger().verbose("Guard - account retrieved, can activate or load");
                return rxjs.of(true);
            }), operators.catchError(function () {
                _this.authService.getLogger().verbose("Guard - error while logging in, unable to activate");
                /**
                 * If a loginFailedRoute is set, checks to see if Angular 10+ is used and state is passed in before returning route
                 * Apps using Angular 9 will receive of(false) in canLoad interface, as it does not support UrlTree return types
                 */
                if (_this.loginFailedRoute && parseInt(core.VERSION.major, 10) > 9 && state) {
                    _this.authService.getLogger().verbose("Guard - loginFailedRoute set, redirecting");
                    return rxjs.of(_this.loginFailedRoute);
                }
                return rxjs.of(false);
            }));
        };
        MsalGuard.prototype.canActivate = function (route, state) {
            this.authService.getLogger().verbose("Guard - canActivate");
            return this.activateHelper(state);
        };
        MsalGuard.prototype.canActivateChild = function (route, state) {
            this.authService.getLogger().verbose("Guard - canActivateChild");
            return this.activateHelper(state);
        };
        MsalGuard.prototype.canLoad = function () {
            this.authService.getLogger().verbose("Guard - canLoad");
            // @ts-ignore
            return this.activateHelper();
        };
        return MsalGuard;
    }());
    MsalGuard.decorators = [
        { type: core.Injectable }
    ];
    MsalGuard.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_GUARD_CONFIG,] }] },
        { type: MsalService },
        { type: common.Location },
        { type: router.Router }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalInterceptor = /** @class */ (function () {
        function MsalInterceptor(msalInterceptorConfig, authService) {
            this.msalInterceptorConfig = msalInterceptorConfig;
            this.authService = authService;
        }
        MsalInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Interceptor activated");
            var scopes = this.getScopesForEndpoint(req.url);
            // Sets account as active account or first account
            var account;
            if (!!this.authService.instance.getActiveAccount()) {
                this.authService.getLogger().verbose("Interceptor - active account selected");
                account = this.authService.instance.getActiveAccount();
            }
            else {
                this.authService.getLogger().verbose("Interceptor - no active account, fallback to first account");
                account = this.authService.instance.getAllAccounts()[0];
            }
            // If no scopes for endpoint, does not acquire token
            if (!scopes || scopes.length === 0) {
                this.authService.getLogger().verbose("Interceptor - no scopes for endpoint");
                return next.handle(req);
            }
            this.authService.getLogger().info("Interceptor - " + scopes.length + " scopes found for endpoint");
            this.authService.getLogger().infoPii("Interceptor - [" + scopes + "] scopes found for " + req.url);
            // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken
            return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes: scopes, account: account }))
                .pipe(operators.catchError(function () {
                _this.authService.getLogger().error("Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve.");
                return _this.acquireTokenInteractively(scopes);
            }), operators.switchMap(function (result) {
                if (!result.accessToken) {
                    _this.authService.getLogger().error("Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve.");
                    return _this.acquireTokenInteractively(scopes);
                }
                return rxjs.of(result);
            }), operators.switchMap(function (result) {
                _this.authService.getLogger().verbose("Interceptor - setting authorization headers");
                var headers = req.headers
                    .set("Authorization", "Bearer " + result.accessToken);
                var requestClone = req.clone({ headers: headers });
                return next.handle(requestClone);
            }));
        };
        /**
         * Invoke interaction for the given set of scopes
         * @param scopes Array of scopes for the request
         * @returns Result from the interactive request
         */
        MsalInterceptor.prototype.acquireTokenInteractively = function (scopes) {
            if (this.msalInterceptorConfig.interactionType === msalBrowser.InteractionType.Popup) {
                this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup");
                return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes: scopes }));
            }
            this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
            var redirectStartPage = window.location.href;
            this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes: scopes, redirectStartPage: redirectStartPage }));
            return rxjs.EMPTY;
        };
        /**
         * Looks up the scopes for the given endpoint from the protectedResourceMap
         * @param endpoint Url of the request
         * @returns Array of scopes, or null if not found
         *
         */
        MsalInterceptor.prototype.getScopesForEndpoint = function (endpoint) {
            this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
            var protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());
            var keyMatchesEndpointArray = protectedResourcesArray.filter(function (key) {
                return msalBrowser.StringUtils.matchPattern(key, endpoint);
            });
            // Process all protected resources and send the first matched resource
            if (keyMatchesEndpointArray.length > 0) {
                var keyForEndpoint = keyMatchesEndpointArray[0];
                if (keyForEndpoint) {
                    return this.msalInterceptorConfig.protectedResourceMap.get(keyForEndpoint);
                }
            }
            return null;
        };
        return MsalInterceptor;
    }());
    MsalInterceptor.decorators = [
        { type: core.Injectable }
    ];
    MsalInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INTERCEPTOR_CONFIG,] }] },
        { type: MsalService }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalBroadcastService = /** @class */ (function () {
        function MsalBroadcastService(msalInstance) {
            var _this = this;
            this.msalInstance = msalInstance;
            this._msalSubject = new rxjs.Subject();
            this.msalSubject$ = this._msalSubject.asObservable();
            this._inProgress = new rxjs.Subject();
            this.inProgress$ = this._inProgress.asObservable();
            this.msalInstance.addEventCallback(function (message) {
                _this._msalSubject.next(message);
                var status = msalBrowser.EventMessageUtils.getInteractionStatusFromEvent(message);
                if (status !== null) {
                    _this.msalInstance.getLogger().verbose("BroadcastService - " + message.eventType + " results in setting inProgress to " + status);
                    _this._inProgress.next(status);
                }
            });
        }
        return MsalBroadcastService;
    }());
    MsalBroadcastService.decorators = [
        { type: core.Injectable }
    ];
    MsalBroadcastService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalModule = /** @class */ (function () {
        function MsalModule() {
        }
        MsalModule.forRoot = function (msalInstance, guardConfig, interceptorConfig) {
            return {
                ngModule: MsalModule,
                providers: [
                    {
                        provide: MSAL_INSTANCE,
                        useValue: msalInstance
                    },
                    {
                        provide: MSAL_GUARD_CONFIG,
                        useValue: guardConfig
                    },
                    {
                        provide: MSAL_INTERCEPTOR_CONFIG,
                        useValue: interceptorConfig
                    },
                    MsalService
                ]
            };
        };
        return MsalModule;
    }());
    MsalModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [],
                    imports: [
                        common.CommonModule
                    ],
                    providers: [
                        MsalGuard,
                        MsalBroadcastService
                    ]
                },] }
    ];

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalRedirectComponent = /** @class */ (function () {
        function MsalRedirectComponent(authService) {
            this.authService = authService;
        }
        MsalRedirectComponent.prototype.ngOnInit = function () {
            this.authService.handleRedirectObservable().subscribe();
        };
        return MsalRedirectComponent;
    }());
    MsalRedirectComponent.decorators = [
        { type: core.Component, args: [{
                    selector: "app-redirect",
                    template: ""
                },] }
    ];
    MsalRedirectComponent.ctorParameters = function () { return [
        { type: MsalService }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.MSAL_GUARD_CONFIG = MSAL_GUARD_CONFIG;
    exports.MSAL_INSTANCE = MSAL_INSTANCE;
    exports.MSAL_INTERCEPTOR_CONFIG = MSAL_INTERCEPTOR_CONFIG;
    exports.MsalBroadcastService = MsalBroadcastService;
    exports.MsalGuard = MsalGuard;
    exports.MsalInterceptor = MsalInterceptor;
    exports.MsalModule = MsalModule;
    exports.MsalRedirectComponent = MsalRedirectComponent;
    exports.MsalService = MsalService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=azure-msal-angular.umd.js.map
