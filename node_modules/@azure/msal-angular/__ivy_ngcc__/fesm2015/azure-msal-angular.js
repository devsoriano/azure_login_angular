import { InjectionToken, Injectable, Inject, VERSION, NgModule, Component } from '@angular/core';
import { Location, CommonModule } from '@angular/common';
import { WrapperSKU, InteractionType, BrowserConfigurationAuthError, UrlString, BrowserUtils, StringUtils, EventMessageUtils } from '@azure/msal-browser';
import { from, of, EMPTY, Subject } from 'rxjs';
import { Router } from '@angular/router';
import { map, concatMap, catchError, switchMap } from 'rxjs/operators';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/router';
const MSAL_INSTANCE = new InjectionToken("MSAL_INSTANCE");
const MSAL_GUARD_CONFIG = new InjectionToken("MSAL_GUARD_CONFIG");
const MSAL_INTERCEPTOR_CONFIG = new InjectionToken("MSAL_INTERCEPTOR_CONFIG");

/* eslint-disable header/header */
const name = "@azure/msal-angular";
const version = "2.0.0-alpha.6";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalService {
    constructor(instance, location) {
        this.instance = instance;
        this.location = location;
        const hash = this.location.path(true).split("#").pop();
        if (hash) {
            this.redirectHash = `#${hash}`;
        }
        this.instance.initializeWrapperLibrary(WrapperSKU.Angular, version);
    }
    acquireTokenPopup(request) {
        return from(this.instance.acquireTokenPopup(request));
    }
    acquireTokenRedirect(request) {
        return from(this.instance.acquireTokenRedirect(request));
    }
    acquireTokenSilent(silentRequest) {
        return from(this.instance.acquireTokenSilent(silentRequest));
    }
    handleRedirectObservable() {
        const handleRedirect = from(this.instance.handleRedirectPromise(this.redirectHash));
        this.redirectHash = "";
        return handleRedirect;
    }
    loginPopup(request) {
        return from(this.instance.loginPopup(request));
    }
    loginRedirect(request) {
        return from(this.instance.loginRedirect(request));
    }
    logout(logoutRequest) {
        return from(this.instance.logout(logoutRequest));
    }
    ssoSilent(request) {
        return from(this.instance.ssoSilent(request));
    }
    /**
     * Gets logger for msal-angular.
     * If no logger set, returns logger instance created with same options as msal-browser
     */
    getLogger() {
        if (!this.logger) {
            this.logger = this.instance.getLogger().clone(name, version);
        }
        return this.logger;
    }
    // Create a logger instance for msal-angular with the same options as msal-browser
    setLogger(logger) {
        this.logger = logger.clone(name, version);
        this.instance.setLogger(logger);
    }
}
MsalService.ɵfac = function MsalService_Factory(t) { return new (t || MsalService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE), ɵngcc0.ɵɵinject(ɵngcc1.Location)); };
MsalService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MsalService, factory: MsalService.ɵfac });
MsalService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INSTANCE,] }] },
    { type: Location }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MSAL_INSTANCE]
            }] }, { type: ɵngcc1.Location }]; }, null); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalGuard {
    constructor(msalGuardConfig, authService, location, router) {
        this.msalGuardConfig = msalGuardConfig;
        this.authService = authService;
        this.location = location;
        this.router = router;
    }
    /**
     * Parses url string to UrlTree
     * @param url
     */
    parseUrl(url) {
        return this.router.parseUrl(url);
    }
    /**
     * Builds the absolute url for the destination page
     * @param path Relative path of requested page
     * @returns Full destination url
     */
    getDestinationUrl(path) {
        this.authService.getLogger().verbose("Guard - getting destination url");
        // Absolute base url for the application (default to origin if base element not present)
        const baseElements = document.getElementsByTagName("base");
        const baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
        // Path of page (including hash, if using hash routing)
        const pathUrl = this.location.prepareExternalUrl(path);
        // Hash location strategy
        if (pathUrl.startsWith("#")) {
            this.authService.getLogger().verbose("Guard - destination by hash routing");
            return `${baseUrl}/${pathUrl}`;
        }
        /*
         * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
         * Since baseUrl also includes /base, can just concatentate baseUrl + path
         */
        return `${baseUrl}${path}`;
    }
    /**
     * Interactively prompt the user to login
     * @param url Path of the requested page
     */
    loginInteractively(url) {
        if (this.msalGuardConfig.interactionType === InteractionType.Popup) {
            this.authService.getLogger().verbose("Guard - logging in by popup");
            return this.authService.loginPopup(Object.assign({}, this.msalGuardConfig.authRequest))
                .pipe(map((response) => {
                this.authService.getLogger().verbose("Guard - login by popup successful, can activate, setting active account");
                this.authService.instance.setActiveAccount(response.account);
                return true;
            }));
        }
        this.authService.getLogger().verbose("Guard - logging in by redirect");
        const redirectStartPage = this.getDestinationUrl(url);
        return this.authService.loginRedirect(Object.assign({ redirectStartPage }, this.msalGuardConfig.authRequest))
            .pipe(map(() => false));
    }
    /**
     * Helper which checks for the correct interaction type, prevents page with Guard to be set as reidrect, and calls handleRedirectObservable
     * @param state
     */
    activateHelper(state) {
        if (this.msalGuardConfig.interactionType !== InteractionType.Popup && this.msalGuardConfig.interactionType !== InteractionType.Redirect) {
            throw new BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
        }
        this.authService.getLogger().verbose("MSAL Guard activated");
        /*
         * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
         * short-circuit to prevent redirecting or popups.
         * TODO: Update to allow running in iframe once allowRedirectInIframe is implemented
         */
        if (UrlString.hashContainsKnownProperties(window.location.hash) && BrowserUtils.isInIframe()) {
            this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
            return of(false);
        }
        /**
         * If a loginFailedRoute is set in the config, set this as the loginFailedRoute
         */
        if (this.msalGuardConfig.loginFailedRoute) {
            this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute);
        }
        return this.authService.handleRedirectObservable()
            .pipe(concatMap(() => {
            if (!this.authService.instance.getAllAccounts().length) {
                if (state) {
                    this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate");
                    return this.loginInteractively(state.url);
                }
                this.authService.getLogger().verbose("Guard - no accounts retrieved, no state, cannot load");
                return of(false);
            }
            this.authService.getLogger().verbose("Guard - account retrieved, can activate or load");
            return of(true);
        }), catchError(() => {
            this.authService.getLogger().verbose("Guard - error while logging in, unable to activate");
            /**
             * If a loginFailedRoute is set, checks to see if Angular 10+ is used and state is passed in before returning route
             * Apps using Angular 9 will receive of(false) in canLoad interface, as it does not support UrlTree return types
             */
            if (this.loginFailedRoute && parseInt(VERSION.major, 10) > 9 && state) {
                this.authService.getLogger().verbose("Guard - loginFailedRoute set, redirecting");
                return of(this.loginFailedRoute);
            }
            return of(false);
        }));
    }
    canActivate(route, state) {
        this.authService.getLogger().verbose("Guard - canActivate");
        return this.activateHelper(state);
    }
    canActivateChild(route, state) {
        this.authService.getLogger().verbose("Guard - canActivateChild");
        return this.activateHelper(state);
    }
    canLoad() {
        this.authService.getLogger().verbose("Guard - canLoad");
        // @ts-ignore
        return this.activateHelper();
    }
}
MsalGuard.ɵfac = function MsalGuard_Factory(t) { return new (t || MsalGuard)(ɵngcc0.ɵɵinject(MSAL_GUARD_CONFIG), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc2.Router)); };
MsalGuard.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MsalGuard, factory: MsalGuard.ɵfac });
MsalGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_GUARD_CONFIG,] }] },
    { type: MsalService },
    { type: Location },
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalGuard, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MSAL_GUARD_CONFIG]
            }] }, { type: MsalService }, { type: ɵngcc1.Location }, { type: ɵngcc2.Router }]; }, null); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalInterceptor {
    constructor(msalInterceptorConfig, authService) {
        this.msalInterceptorConfig = msalInterceptorConfig;
        this.authService = authService;
    }
    intercept(req, next) {
        if (this.msalInterceptorConfig.interactionType !== InteractionType.Popup && this.msalInterceptorConfig.interactionType !== InteractionType.Redirect) {
            throw new BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
        }
        this.authService.getLogger().verbose("MSAL Interceptor activated");
        const scopes = this.getScopesForEndpoint(req.url);
        // Sets account as active account or first account
        let account;
        if (!!this.authService.instance.getActiveAccount()) {
            this.authService.getLogger().verbose("Interceptor - active account selected");
            account = this.authService.instance.getActiveAccount();
        }
        else {
            this.authService.getLogger().verbose("Interceptor - no active account, fallback to first account");
            account = this.authService.instance.getAllAccounts()[0];
        }
        // If no scopes for endpoint, does not acquire token
        if (!scopes || scopes.length === 0) {
            this.authService.getLogger().verbose("Interceptor - no scopes for endpoint");
            return next.handle(req);
        }
        this.authService.getLogger().info(`Interceptor - ${scopes.length} scopes found for endpoint`);
        this.authService.getLogger().infoPii(`Interceptor - [${scopes}] scopes found for ${req.url}`);
        // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken
        return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes, account }))
            .pipe(catchError(() => {
            this.authService.getLogger().error("Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve.");
            return this.acquireTokenInteractively(scopes);
        }), switchMap((result) => {
            if (!result.accessToken) {
                this.authService.getLogger().error("Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve.");
                return this.acquireTokenInteractively(scopes);
            }
            return of(result);
        }), switchMap((result) => {
            this.authService.getLogger().verbose("Interceptor - setting authorization headers");
            const headers = req.headers
                .set("Authorization", `Bearer ${result.accessToken}`);
            const requestClone = req.clone({ headers });
            return next.handle(requestClone);
        }));
    }
    /**
     * Invoke interaction for the given set of scopes
     * @param scopes Array of scopes for the request
     * @returns Result from the interactive request
     */
    acquireTokenInteractively(scopes) {
        if (this.msalInterceptorConfig.interactionType === InteractionType.Popup) {
            this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup");
            return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes }));
        }
        this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
        const redirectStartPage = window.location.href;
        this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes, redirectStartPage }));
        return EMPTY;
    }
    /**
     * Looks up the scopes for the given endpoint from the protectedResourceMap
     * @param endpoint Url of the request
     * @returns Array of scopes, or null if not found
     *
     */
    getScopesForEndpoint(endpoint) {
        this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
        const protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());
        const keyMatchesEndpointArray = protectedResourcesArray.filter(key => {
            return StringUtils.matchPattern(key, endpoint);
        });
        // Process all protected resources and send the first matched resource
        if (keyMatchesEndpointArray.length > 0) {
            const keyForEndpoint = keyMatchesEndpointArray[0];
            if (keyForEndpoint) {
                return this.msalInterceptorConfig.protectedResourceMap.get(keyForEndpoint);
            }
        }
        return null;
    }
}
MsalInterceptor.ɵfac = function MsalInterceptor_Factory(t) { return new (t || MsalInterceptor)(ɵngcc0.ɵɵinject(MSAL_INTERCEPTOR_CONFIG), ɵngcc0.ɵɵinject(MsalService)); };
MsalInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MsalInterceptor, factory: MsalInterceptor.ɵfac });
MsalInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INTERCEPTOR_CONFIG,] }] },
    { type: MsalService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MSAL_INTERCEPTOR_CONFIG]
            }] }, { type: MsalService }]; }, null); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalBroadcastService {
    constructor(msalInstance) {
        this.msalInstance = msalInstance;
        this._msalSubject = new Subject();
        this.msalSubject$ = this._msalSubject.asObservable();
        this._inProgress = new Subject();
        this.inProgress$ = this._inProgress.asObservable();
        this.msalInstance.addEventCallback((message) => {
            this._msalSubject.next(message);
            const status = EventMessageUtils.getInteractionStatusFromEvent(message);
            if (status !== null) {
                this.msalInstance.getLogger().verbose(`BroadcastService - ${message.eventType} results in setting inProgress to ${status}`);
                this._inProgress.next(status);
            }
        });
    }
}
MsalBroadcastService.ɵfac = function MsalBroadcastService_Factory(t) { return new (t || MsalBroadcastService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE)); };
MsalBroadcastService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MsalBroadcastService, factory: MsalBroadcastService.ɵfac });
MsalBroadcastService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INSTANCE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalBroadcastService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MSAL_INSTANCE]
            }] }]; }, null); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalModule {
    static forRoot(msalInstance, guardConfig, interceptorConfig) {
        return {
            ngModule: MsalModule,
            providers: [
                {
                    provide: MSAL_INSTANCE,
                    useValue: msalInstance
                },
                {
                    provide: MSAL_GUARD_CONFIG,
                    useValue: guardConfig
                },
                {
                    provide: MSAL_INTERCEPTOR_CONFIG,
                    useValue: interceptorConfig
                },
                MsalService
            ]
        };
    }
}
MsalModule.ɵfac = function MsalModule_Factory(t) { return new (t || MsalModule)(); };
MsalModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MsalModule });
MsalModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        MsalGuard,
        MsalBroadcastService
    ], imports: [CommonModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalModule, [{
        type: NgModule,
        args: [{
                declarations: [],
                imports: [
                    CommonModule
                ],
                providers: [
                    MsalGuard,
                    MsalBroadcastService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MsalModule, { imports: function () { return [CommonModule]; } }); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalRedirectComponent {
    constructor(authService) {
        this.authService = authService;
    }
    ngOnInit() {
        this.authService.handleRedirectObservable().subscribe();
    }
}
MsalRedirectComponent.ɵfac = function MsalRedirectComponent_Factory(t) { return new (t || MsalRedirectComponent)(ɵngcc0.ɵɵdirectiveInject(MsalService)); };
MsalRedirectComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MsalRedirectComponent, selectors: [["app-redirect"]], decls: 0, vars: 0, template: function MsalRedirectComponent_Template(rf, ctx) { }, encapsulation: 2 });
MsalRedirectComponent.ctorParameters = () => [
    { type: MsalService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MsalRedirectComponent, [{
        type: Component,
        args: [{
                selector: "app-redirect",
                template: ""
            }]
    }], function () { return [{ type: MsalService }]; }, null); })();

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MSAL_GUARD_CONFIG, MSAL_INSTANCE, MSAL_INTERCEPTOR_CONFIG, MsalBroadcastService, MsalGuard, MsalInterceptor, MsalModule, MsalRedirectComponent, MsalService };

//# sourceMappingURL=azure-msal-angular.js.map